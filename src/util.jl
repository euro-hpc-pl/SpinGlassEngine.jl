export exact_marginal_probability,
    exact_conditional_probability,
    conditional_probability,
    update_energy,
    error_measure,
    exact_spectrum

"""
$(TYPEDSIGNATURES)

Calculate the exact spectrum and corresponding eigenstates for a clustered Hamiltonian using memoization.

## Arguments
- `clustered_hamiltonian::LabelledGraph{S, T}`: A clustered Hamiltonian represented as a labelled graph.
    
## Returns
- Tuple `(energies, states)`: A tuple containing the calculated energies and corresponding eigenstates.
    
## Description
The `exact_spectrum` function calculates the exact spectrum and corresponding eigenstates for a clustered Hamiltonian using memoization. 
The function utilizes memoization to efficiently store and retrieve previously computed results for different inputs, reducing redundant calculations.
The Hamiltonian is represented as a labelled graph (`LabelledGraph`) with vertices corresponding to clusters and edges 
representing interactions between clusters.
"""
@memoize function exact_spectrum(clustered_hamiltonian::LabelledGraph{S,T}) where {S,T}
    # TODO: Not going to work without PoolOfProjectors
    ver = vertices(clustered_hamiltonian)
    rank = cluster_size.(Ref(clustered_hamiltonian), ver)
    states = [Dict(ver .=> σ) for σ ∈ Iterators.product([1:r for r ∈ rank]...)]
    energy.(Ref(clustered_hamiltonian), states), states
end

"""
$(TYPEDSIGNATURES)
Calculate the exact marginal probability of a target state within the context of an MPS (Matrix Product State) contractor.

## Arguments
- `ctr::MpsContractor{T}`: An MPS contractor representing the contracted state and associated parameters.
- `σ::Vector{Int}`: A vector representing the encoded state.

## Returns
- `Float64`: The calculated exact marginal probability of the target state.

## Description
The `exact_marginal_probability` function calculates the exact marginal probability of a target state within the context of an MPS contractor. 
It decodes the provided state vector `σ` using the `decode_state` function, obtains the exact spectrum and states 
from the clustered Hamiltonian of the associated PEPS, and computes the marginal probability of the target state using the Boltzmann distribution.
The function utilizes the `exact_spectrum` function to obtain the energies and states of the clustered Hamiltonian, 
exponentiates the negative energies multiplied by the inverse temperature (`ctr.betas[end]`), normalizes the probabilities, 
and calculates the marginal probability of the target state.
"""
function exact_marginal_probability(ctr::MpsContractor{T}, σ::Vector{Int}) where {T}
    # TODO: Not going to work without PoolOfProjectors
    target_state = decode_state(ctr.peps, σ, true)
    energies, states = exact_spectrum(ctr.peps.clustered_hamiltonian)
    prob = exp.(-ctr.betas[end] .* energies)
    prob ./= sum(prob)
    sum(prob[findall([all(s[k] == v for (k, v) ∈ target_state) for s ∈ states])])
end

"""
$(TYPEDSIGNATURES)
Calculate the exact conditional probability of a target state within the context of an MPS (Matrix Product State) contractor.

## Arguments
- `ctr::MpsContractor{T}`: An MPS contractor representing the contracted state and associated parameters.
- `σ::Vector{Int}`: A vector representing the encoded state.

## Returns
- `Vector{Float64}`: The calculated exact conditional probabilities for each possible outcome.

## Description
The `exact_conditional_probability` function calculates the exact conditional probability distribution of a target state within the context of an MPS contractor. 
It uses the `exact_marginal_probability` function for different branch states generated by `branch_state` and normalizes the probabilities.
"""
function exact_conditional_probability(ctr::MpsContractor{T}, σ::Vector{Int}) where {T}
    # TODO: Not going to work without PoolOfProjectors
    local_basis = collect(1:cluster_size(ctr.peps, ctr.current_node))
    probs = exact_marginal_probability.(Ref(ctr), branch_state(local_basis, σ))
    probs ./= sum(probs)
end

"""
$(TYPEDSIGNATURES)
Calculate the conditional probability of a given state within the context of an MPS (Matrix Product State) contractor.

## Arguments
- `ctr::MpsContractor{S}`: An MPS contractor representing the contracted state and associated parameters.
- `w::Vector{Int}`: A vector representing the encoded state.

## Returns
- `Vector{Float64}`: The calculated conditional probabilities for each possible outcome.

## Description
The `conditional_probability` function calculates the conditional probability distribution of a given state within the context of an MPS contractor. 
It delegates the calculation to the `conditional_probability` function with a specified tensor layout using the `layout` function.
This function is a convenience wrapper that allows users to calculate conditional probabilities without explicitly specifying the tensor layout.

"""
function conditional_probability(ctr::MpsContractor{S}, w::Vector{Int}) where {S}
    conditional_probability(layout(ctr.peps), ctr, w)
end

"""
$(TYPEDSIGNATURES)
Update the energy associated with the current state within the context of an MPS (Matrix Product State) contractor.

## Arguments
- `ctr::MpsContractor{S}`: An MPS contractor representing the contracted state and associated parameters.
- `w::Vector{Int}`: A vector representing the encoded state.

## Description
The `update_energy` function updates the energy associated with the current state within the context of an MPS contractor. 
It delegates the calculation to the `update_energy` function with a specified tensor layout using the `layout` function.
This function is a convenience wrapper that allows users to update the energy without explicitly specifying the tensor layout.

"""
function update_energy(ctr::MpsContractor{S}, w::Vector{Int}) where {S}
    update_energy(layout(ctr.peps), ctr, w)
end

"""
$(TYPEDSIGNATURES)
Calculate an error measure based on the given probability distribution.

## Arguments
- `probs`: An array representing a probability distribution.

## Description
The `error_measure` function calculates an error measure based on the provided probability distribution. 
The error measure is designed to capture discrepancies or irregularities in the distribution.
The function checks for extreme cases, such as when the maximum probability less or equal zero, and returns a predefined value (`2.0`). 
If the minimum probability is negative, the error measure is calculated as the absolute value of the minimum 
probability divided by the maximum absolute value of the probabilities. 
If neither of these conditions is met, the error measure is set to `0.0`.
The error measure provides a quantitative assessment of the deviation from a well-behaved probability distribution, 
helping to identify potential issues or anomalies.
"""
function error_measure(probs)
    if maximum(probs) <= 0
        return 2.0
    end
    if minimum(probs) < 0
        return abs(minimum(probs)) / maximum(abs.(probs))
    end
    return 0.0
end
